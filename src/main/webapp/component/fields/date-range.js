import { __assign, __read } from "tslib";
import { jsx as _jsx, jsxs as _jsxs, Fragment as _Fragment } from "react/jsx-runtime";
/**
 * Copyright (c) Codice Foundation
 *
 * This is free software: you can redistribute it and/or modify it under the terms of the GNU Lesser
 * General Public License as published by the Free Software Foundation, either version 3 of the
 * License, or any later version.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without
 * even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details. A copy of the GNU Lesser General Public License
 * is distributed along with this program and can be found at
 * <http://www.gnu.org/licenses/lgpl.html>.
 *
 **/
import * as React from 'react';
import { DateRangeInput } from '@blueprintjs/datetime';
import { DateHelpers, DefaultMaxDate, DefaultMinDate } from './date-helpers';
import { MuiOutlinedInputBorderClasses } from '../theme/theme';
import useTimePrefs from './useTimePrefs';
import user from '../singletons/user-instance';
import { EnterKeySubmitProps } from '../custom-events/enter-key-submit';
import FormHelperText from '@mui/material/FormHelperText';
import LinearProgress from '@mui/material/LinearProgress';
export function defaultValue() {
    var end = DateHelpers.General.withPrecision(new Date());
    var start = DateHelpers.General.withPrecision(new Date(end.valueOf() - 86400000)); // start and end can't be equal or the backend will throw a fit
    return {
        start: start.toISOString(),
        end: end.toISOString(),
    };
}
/**
 *  Used in the below components to test values for validity and to provide a message to the user if they are invalid.
 */
function isValidValue(value) {
    if (value && value.start && value.end) {
        // end has to be after start too, so convert from iso and check
        var startDate = new Date(value.start);
        var endDate = new Date(value.end);
        return {
            valid: startDate < endDate,
            message: 'Start date must be before end date, using previous valid values:',
        };
    }
    else {
        return {
            valid: false,
            message: 'Start and end date must be set, using previous valid values:',
        };
    }
}
/**
 *  There are two things to check before passing values upwards to parent components through the onChange.
 *  1.  Start and end date need to be valid dates.
 *  2.  Start date must be before end date. (cannot be equal either)
 *
 *  Given those possibilities, we can construct a message to try and prod the user as to why a value is invalid.
 */
function useLocalValue(_a) {
    var value = _a.value, onChange = _a.onChange;
    var _b = __read(React.useState(value), 2), localValue = _b[0], setLocalValue = _b[1]; // since we don't get here with an invalid value, we can just set it to the value
    var _c = __read(React.useState(false), 2), hasValidationIssues = _c[0], setHasValidationIssues = _c[1];
    var _d = __read(React.useState(null), 2), constructedValidationText = _d[0], setConstructedValidationText = _d[1];
    React.useEffect(function () {
        var validity = isValidValue(localValue);
        if (onChange && validity.valid) {
            setHasValidationIssues(false);
            setConstructedValidationText('');
            if (value !== localValue)
                onChange(localValue);
        }
        else {
            setConstructedValidationText(_jsxs(_Fragment, { children: [_jsx("div", { children: validity.message }), _jsxs("div", { children: ["start: ", value.start] }), _jsxs("div", { children: ["end: ", value.end] })] }));
            setHasValidationIssues(true);
        }
    }, [localValue, value]);
    return {
        localValue: localValue,
        setLocalValue: setLocalValue,
        hasValidationIssues: hasValidationIssues,
        constructedValidationText: constructedValidationText,
    };
}
/**
 *  If the initial value is invalid, we immediately call the onChange to make sure we start with a valid value.
 */
function useInitialValueValidation(_a) {
    var value = _a.value, onChange = _a.onChange;
    React.useEffect(function () {
        if (!isValidValue(value).valid) {
            onChange(defaultValue());
        }
    }, []);
}
/**
 *  This component will always have a valid value (start and end date set and start < end), and onChange will never get an invalid value
 */
var DateRangeFieldWithoutInitialValidation = React.forwardRef(function (_a, ref) {
    var value = _a.value, onChange = _a.onChange, BPDateRangeProps = _a.BPDateRangeProps;
    var _b = useLocalValue({ value: value, onChange: onChange }), localValue = _b.localValue, setLocalValue = _b.setLocalValue, hasValidationIssues = _b.hasValidationIssues, constructedValidationText = _b.constructedValidationText;
    useTimePrefs(function () {
        var shiftedDates = DateHelpers.Blueprint.DateRangeProps.generateValue(value); // as said above, this will always be valid, so no need to fret on converting
        setLocalValue({
            start: DateHelpers.Blueprint.converters
                .UntimeshiftFromDatePicker(shiftedDates[0])
                .toISOString(),
            end: DateHelpers.Blueprint.converters
                .UntimeshiftFromDatePicker(shiftedDates[1])
                .toISOString(),
        });
    });
    return (_jsxs(_Fragment, { children: [_jsx(DateRangeInput, __assign({ ref: ref, timePickerProps: {
                    useAmPm: user.getAmPmDisplay(),
                }, allowSingleDayRange: true, minDate: DefaultMinDate, maxDate: DefaultMaxDate, endInputProps: __assign({ fill: true, className: MuiOutlinedInputBorderClasses }, EnterKeySubmitProps), startInputProps: __assign({ fill: true, className: MuiOutlinedInputBorderClasses }, EnterKeySubmitProps), className: "where", closeOnSelection: false, formatDate: DateHelpers.Blueprint.commonProps.formatDate, onChange: DateHelpers.Blueprint.DateRangeProps.generateOnChange(function (value) {
                    setLocalValue(value);
                }), popoverProps: {
                    boundary: 'viewport',
                    position: 'bottom',
                }, parseDate: DateHelpers.Blueprint.commonProps.parseDate, shortcuts: true, timePrecision: DateHelpers.General.getTimePrecision(), placeholder: DateHelpers.General.getDateFormat(), value: DateHelpers.Blueprint.DateRangeProps.generateValue(localValue) }, BPDateRangeProps)), hasValidationIssues ? (_jsx(_Fragment, { children: _jsx(FormHelperText, { className: "px-2 Mui-text-error", children: constructedValidationText }) })) : null] }));
});
/**
 *  By updating invalid starting values before we go into the above component, we can make sure we always have a valid value to fall back to.
 */
export var DateRangeField = React.forwardRef(function (_a, ref) {
    var value = _a.value, onChange = _a.onChange, BPDateRangeProps = _a.BPDateRangeProps;
    useInitialValueValidation({ value: value, onChange: onChange, BPDateRangeProps: BPDateRangeProps });
    var valueValidity = isValidValue(value);
    if (!valueValidity.valid) {
        return _jsx(LinearProgress, { className: "w-full h-2" });
    }
    return (_jsx(DateRangeFieldWithoutInitialValidation, { ref: ref, value: value, onChange: onChange, BPDateRangeProps: BPDateRangeProps }));
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGF0ZS1yYW5nZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uL3NyYy9tYWluL3dlYmFwcC9jb21wb25lbnQvZmllbGRzL2RhdGUtcmFuZ2UudHN4Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBQUE7Ozs7Ozs7Ozs7Ozs7SUFhSTtBQUNKLE9BQU8sS0FBSyxLQUFLLE1BQU0sT0FBTyxDQUFBO0FBQzlCLE9BQU8sRUFBRSxjQUFjLEVBQXVCLE1BQU0sdUJBQXVCLENBQUE7QUFDM0UsT0FBTyxFQUFFLFdBQVcsRUFBRSxjQUFjLEVBQUUsY0FBYyxFQUFFLE1BQU0sZ0JBQWdCLENBQUE7QUFFNUUsT0FBTyxFQUFFLDZCQUE2QixFQUFFLE1BQU0sZ0JBQWdCLENBQUE7QUFDOUQsT0FBTyxZQUFZLE1BQU0sZ0JBQWdCLENBQUE7QUFFekMsT0FBTyxJQUFJLE1BQU0sNkJBQTZCLENBQUE7QUFDOUMsT0FBTyxFQUFFLG1CQUFtQixFQUFFLE1BQU0sbUNBQW1DLENBQUE7QUFDdkUsT0FBTyxjQUFjLE1BQU0sOEJBQThCLENBQUE7QUFDekQsT0FBTyxjQUFjLE1BQU0sOEJBQThCLENBQUE7QUFlekQsTUFBTSxVQUFVLFlBQVk7SUFDMUIsSUFBTSxHQUFHLEdBQUcsV0FBVyxDQUFDLE9BQU8sQ0FBQyxhQUFhLENBQUMsSUFBSSxJQUFJLEVBQUUsQ0FBQyxDQUFBO0lBQ3pELElBQU0sS0FBSyxHQUFHLFdBQVcsQ0FBQyxPQUFPLENBQUMsYUFBYSxDQUM3QyxJQUFJLElBQUksQ0FBQyxHQUFHLENBQUMsT0FBTyxFQUFFLEdBQUcsUUFBVSxDQUFDLENBQ3JDLENBQUEsQ0FBQywrREFBK0Q7SUFDakUsT0FBTztRQUNMLEtBQUssRUFBRSxLQUFLLENBQUMsV0FBVyxFQUFFO1FBQzFCLEdBQUcsRUFBRSxHQUFHLENBQUMsV0FBVyxFQUFFO0tBQ3ZCLENBQUE7QUFDSCxDQUFDO0FBRUQ7O0dBRUc7QUFDSCxTQUFTLFlBQVksQ0FBQyxL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QUFLLEVBQ1osUUFBUSxFQUFFLFFBQVEsRUFDbEIsZ0JBQWdCLEVBQUUsZ0JBQWdCLEdBQ2xDLENBQ0gsQ0FBQTtBQUNILENBQUMsQ0FDRixDQUFBIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIENvZGljZSBGb3VuZGF0aW9uXG4gKlxuICogVGhpcyBpcyBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5IGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlclxuICogR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnkgdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGVcbiAqIExpY2Vuc2UsIG9yIGFueSBsYXRlciB2ZXJzaW9uLlxuICpcbiAqIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLCBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXRcbiAqIGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2YgTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiBTZWUgdGhlIEdOVVxuICogTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy4gQSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiAqIGlzIGRpc3RyaWJ1dGVkIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtIGFuZCBjYW4gYmUgZm91bmQgYXRcbiAqIDxodHRwOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvbGdwbC5odG1sPi5cbiAqXG4gKiovXG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCdcbmltcG9ydCB7IERhdGVSYW5nZUlucHV0LCBEYXRlUmFuZ2VJbnB1dFByb3BzIH0gZnJvbSAnQGJsdWVwcmludGpzL2RhdGV0aW1lJ1xuaW1wb3J0IHsgRGF0ZUhlbHBlcnMsIERlZmF1bHRNYXhEYXRlLCBEZWZhdWx0TWluRGF0ZSB9IGZyb20gJy4vZGF0ZS1oZWxwZXJzJ1xuaW1wb3J0IHsgVmFsdWVUeXBlcyB9IGZyb20gJy4uL2ZpbHRlci1idWlsZGVyL2ZpbHRlci5zdHJ1Y3R1cmUnXG5pbXBvcnQgeyBNdWlPdXRsaW5lZElucHV0Qm9yZGVyQ2xhc3NlcyB9IGZyb20gJy4uL3RoZW1lL3RoZW1lJ1xuaW1wb3J0IHVzZVRpbWVQcmVmcyBmcm9tICcuL3VzZVRpbWVQcmVmcydcblxuaW1wb3J0IHVzZXIgZnJvbSAnLi4vc2luZ2xldG9ucy91c2VyLWluc3RhbmNlJ1xuaW1wb3J0IHsgRW50ZXJLZXlTdWJtaXRQcm9wcyB9IGZyb20gJy4uL2N1c3RvbS1ldmVudHMvZW50ZXIta2V5LXN1Ym1pdCdcbmltcG9ydCBGb3JtSGVscGVyVGV4dCBmcm9tICdAbXVpL21hdGVyaWFsL0Zvcm1IZWxwZXJUZXh0J1xuaW1wb3J0IExpbmVhclByb2dyZXNzIGZyb20gJ0BtdWkvbWF0ZXJpYWwvTGluZWFyUHJvZ3Jlc3MnXG5cbnR5cGUgUHJvcHMgPSB7XG4gIHZhbHVlOiBWYWx1ZVR5cGVzWydkdXJpbmcnXVxuICBvbkNoYW5nZTogKHZhbHVlOiBWYWx1ZVR5cGVzWydkdXJpbmcnXSkgPT4gdm9pZFxuICAvKipcbiAgICogT3ZlcnJpZGUgaWYgeW91IGFic29sdXRlbHkgbXVzdFxuICAgKi9cbiAgQlBEYXRlUmFuZ2VQcm9wcz86IFBhcnRpYWw8RGF0ZVJhbmdlSW5wdXRQcm9wcz5cbiAgLyoqXG4gICAqIE9wdGlvbmFsIHJlZiB0byBhY2Nlc3MgdGhlIHVuZGVybHlpbmcgQmx1ZXByaW50IERhdGVSYW5nZUlucHV0IGNvbXBvbmVudFxuICAgKi9cbiAgcmVmPzogUmVhY3QuUmVmT2JqZWN0PERhdGVSYW5nZUlucHV0PlxufVxuXG5leHBvcnQgZnVuY3Rpb24gZGVmYXVsdFZhbHVlKCkge1xuICBjb25zdCBlbmQgPSBEYXRlSGVscGVycy5HZW5lcmFsLndpdGhQcmVjaXNpb24obmV3IERhdGUoKSlcbiAgY29uc3Qgc3RhcnQgPSBEYXRlSGVscGVycy5HZW5lcmFsLndpdGhQcmVjaXNpb24oXG4gICAgbmV3IERhdGUoZW5kLnZhbHVlT2YoKSAtIDg2XzQwMF8wMDApXG4gICkgLy8gc3RhcnQgYW5kIGVuZCBjYW4ndCBiZSBlcXVhbCBvciB0aGUgYmFja2VuZCB3aWxsIHRocm93IGEgZml0XG4gIHJldHVybiB7XG4gICAgc3RhcnQ6IHN0YXJ0LnRvSVNPU3RyaW5nKCksXG4gICAgZW5kOiBlbmQudG9JU09TdHJpbmcoKSxcbiAgfVxufVxuXG4vKipcbiAqICBVc2VkIGluIHRoZSBiZWxvdyBjb21wb25lbnRzIHRvIHRlc3QgdmFsdWVzIGZvciB2YWxpZGl0eSBhbmQgdG8gcHJvdmlkZSBhIG1lc3NhZ2UgdG8gdGhlIHVzZXIgaWYgdGhleSBhcmUgaW52YWxpZC5cbiAqL1xuZnVuY3Rpb24gaXNWYWxpZFZhbHVlKHZhbHVlOiBQcm9wc1sndmFsdWUnXSk6IHtcbiAgdmFsaWQ6IGJvb2xlYW5cbiAgbWVzc2FnZTogc3RyaW5nXG59IHtcbiAgaWYgKHZhbHVlICYmIHZhbHVlLnN0YXJ0ICYmIHZhbHVlLmVuZCkge1xuICAgIC8vIGVuZCBoYXMgdG8gYmUgYWZ0ZXIgc3RhcnQgdG9vLCBzbyBjb252ZXJ0IGZyb20gaXNvIGFuZCBjaGVja1xuICAgIGNvbnN0IHN0YXJ0RGF0ZSA9IG5ldyBEYXRlKHZhbHVlLnN0YXJ0KVxuICAgIGNvbnN0IGVuZERhdGUgPSBuZXcgRGF0ZSh2YWx1ZS5lbmQpXG4gICAgcmV0dXJuIHtcbiAgICAgIHZhbGlkOiBzdGFydERhdGUgPCBlbmREYXRlLFxuICAgICAgbWVzc2FnZTpcbiAgICAgICAgJ1N0YXJ0IGRhdGUgbXVzdCBiZSBiZWZvcmUgZW5kIGRhdGUsIHVzaW5nIHByZXZpb3VzIHZhbGlkIHZhbHVlczonLFxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByZXR1cm4ge1xuICAgICAgdmFsaWQ6IGZhbHNlLFxuICAgICAgbWVzc2FnZTogJ1N0YXJ0IGFuZCBlbmQgZGF0ZSBtdXN0IGJlIHNldCwgdXNpbmcgcHJldmlvdXMgdmFsaWQgdmFsdWVzOicsXG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogIFRoZXJlIGFyZSB0d28gdGhpbmdzIHRvIGNoZWNrIGJlZm9yZSBwYXNzaW5nIHZhbHVlcyB1cHdhcmRzIHRvIHBhcmVudCBjb21wb25lbnRzIHRocm91Z2ggdGhlIG9uQ2hhbmdlLlxuICogIDEuICBTdGFydCBhbmQgZW5kIGRhdGUgbmVlZCB0byBiZSB2YWxpZCBkYXRlcy5cbiAqICAyLiAgU3RhcnQgZGF0ZSBtdXN0IGJlIGJlZm9yZSBlbmQgZGF0ZS4gKGNhbm5vdCBiZSBlcXVhbCBlaXRoZXIpXG4gKlxuICogIEdpdmVuIHRob3NlIHBvc3NpYmlsaXRpZXMsIHdlIGNhbiBjb25zdHJ1Y3QgYSBtZXNzYWdlIHRvIHRyeSBhbmQgcHJvZCB0aGUgdXNlciBhcyB0byB3aHkgYSB2YWx1ZSBpcyBpbnZhbGlkLlxuICovXG5mdW5jdGlvbiB1c2VMb2NhbFZhbHVlKHsgdmFsdWUsIG9uQ2hhbmdlIH06IFByb3BzKSB7XG4gIGNvbnN0IFtsb2NhbFZhbHVlLCBzZXRMb2NhbFZhbHVlXSA9IFJlYWN0LnVzZVN0YXRlPFByb3BzWyd2YWx1ZSddPih2YWx1ZSkgLy8gc2luY2Ugd2UgZG9uJ3QgZ2V0IGhlcmUgd2l0aCBhbiBpbnZhbGlkIHZhbHVlLCB3ZSBjYW4ganVzdCBzZXQgaXQgdG8gdGhlIHZhbHVlXG4gIGNvbnN0IFtoYXNWYWxpZGF0aW9uSXNzdWVzLCBzZXRIYXNWYWxpZGF0aW9uSXNzdWVzXSA9IFJlYWN0LnVzZVN0YXRlKGZhbHNlKVxuICBjb25zdCBbY29uc3RydWN0ZWRWYWxpZGF0aW9uVGV4dCwgc2V0Q29uc3RydWN0ZWRWYWxpZGF0aW9uVGV4dF0gPVxuICAgIFJlYWN0LnVzZVN0YXRlPFJlYWN0LlJlYWN0Tm9kZT4obnVsbClcblxuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IHZhbGlkaXR5ID0gaXNWYWxpZFZhbHVlKGxvY2FsVmFsdWUpXG4gICAgaWYgKG9uQ2hhbmdlICYmIHZhbGlkaXR5LnZhbGlkKSB7XG4gICAgICBzZXRIYXNWYWxpZGF0aW9uSXNzdWVzKGZhbHNlKVxuICAgICAgc2V0Q29uc3RydWN0ZWRWYWxpZGF0aW9uVGV4dCgnJylcbiAgICAgIGlmICh2YWx1ZSAhPT0gbG9jYWxWYWx1ZSkgb25DaGFuZ2UobG9jYWxWYWx1ZSlcbiAgICB9IGVsc2Uge1xuICAgICAgc2V0Q29uc3RydWN0ZWRWYWxpZGF0aW9uVGV4dChcbiAgICAgICAgPD5cbiAgICAgICAgICA8ZGl2Pnt2YWxpZGl0eS5tZXNzYWdlfTwvZGl2PlxuICAgICAgICAgIDxkaXY+c3RhcnQ6IHt2YWx1ZS5zdGFydH08L2Rpdj5cbiAgICAgICAgICA8ZGl2PmVuZDoge3ZhbHVlLmVuZH08L2Rpdj5cbiAgICAgICAgPC8+XG4gICAgICApXG4gICAgICBzZXRIYXNWYWxpZGF0aW9uSXNzdWVzKHRydWUpXG4gICAgfVxuICB9LCBbbG9jYWxWYWx1ZSwgdmFsdWVdKVxuXG4gIHJldHVybiB7XG4gICAgbG9jYWxWYWx1ZSxcbiAgICBzZXRMb2NhbFZhbHVlLFxuICAgIGhhc1ZhbGlkYXRpb25Jc3N1ZXMsXG4gICAgY29uc3RydWN0ZWRWYWxpZGF0aW9uVGV4dCxcbiAgfVxufVxuXG4vKipcbiAqICBJZiB0aGUgaW5pdGlhbCB2YWx1ZSBpcyBpbnZhbGlkLCB3ZSBpbW1lZGlhdGVseSBjYWxsIHRoZSBvbkNoYW5nZSB0byBtYWtlIHN1cmUgd2Ugc3RhcnQgd2l0aCBhIHZhbGlkIHZhbHVlLlxuICovXG5mdW5jdGlvbiB1c2VJbml0aWFsVmFsdWVWYWxpZGF0aW9uKHsgdmFsdWUsIG9uQ2hhbmdlIH06IFByb3BzKSB7XG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCFpc1ZhbGlkVmFsdWUodmFsdWUpLnZhbGlkKSB7XG4gICAgICBvbkNoYW5nZShkZWZhdWx0VmFsdWUoKSlcbiAgICB9XG4gIH0sIFtdKVxufVxuXG4vKipcbiAqICBUaGlzIGNvbXBvbmVudCB3aWxsIGFsd2F5cyBoYXZlIGEgdmFsaWQgdmFsdWUgKHN0YXJ0IGFuZCBlbmQgZGF0ZSBzZXQgYW5kIHN0YXJ0IDwgZW5kKSwgYW5kIG9uQ2hhbmdlIHdpbGwgbmV2ZXIgZ2V0IGFuIGludmFsaWQgdmFsdWVcbiAqL1xuY29uc3QgRGF0ZVJhbmdlRmllbGRXaXRob3V0SW5pdGlhbFZhbGlkYXRpb24gPSBSZWFjdC5mb3J3YXJkUmVmKFxuICAoXG4gICAgeyB2YWx1ZSwgb25DaGFuZ2UsIEJQRGF0ZVJhbmdlUHJvcHMgfTogUHJvcHMsXG4gICAgcmVmOiBSZWFjdC5SZWY8RGF0ZVJhbmdlSW5wdXQ+XG4gICkgPT4ge1xuICAgIGNvbnN0IHtcbiAgICAgIGxvY2FsVmFsdWUsXG4gICAgICBzZXRMb2NhbFZhbHVlLFxuICAgICAgaGFzVmFsaWRhdGlvbklzc3VlcyxcbiAgICAgIGNvbnN0cnVjdGVkVmFsaWRhdGlvblRleHQsXG4gICAgfSA9IHVzZUxvY2FsVmFsdWUoeyB2YWx1ZSwgb25DaGFuZ2UgfSlcbiAgICB1c2VUaW1lUHJlZnMoKCkgPT4ge1xuICAgICAgY29uc3Qgc2hpZnRlZERhdGVzID1cbiAgICAgICAgRGF0ZUhlbHBlcnMuQmx1ZXByaW50LkRhdGVSYW5nZVByb3BzLmdlbmVyYXRlVmFsdWUodmFsdWUpIC8vIGFzIHNhaWQgYWJvdmUsIHRoaXMgd2lsbCBhbHdheXMgYmUgdmFsaWQsIHNvIG5vIG5lZWQgdG8gZnJldCBvbiBjb252ZXJ0aW5nXG4gICAgICBzZXRMb2NhbFZhbHVlKHtcbiAgICAgICAgc3RhcnQ6IERhdGVIZWxwZXJzLkJsdWVwcmludC5jb252ZXJ0ZXJzXG4gICAgICAgICAgLlVudGltZXNoaWZ0RnJvbURhdGVQaWNrZXIoc2hpZnRlZERhdGVzIVswXSEpXG4gICAgICAgICAgLnRvSVNPU3RyaW5nKCksXG4gICAgICAgIGVuZDogRGF0ZUhlbHBlcnMuQmx1ZXByaW50LmNvbnZlcnRlcnNcbiAgICAgICAgICAuVW50aW1lc2hpZnRGcm9tRGF0ZVBpY2tlcihzaGlmdGVkRGF0ZXMhWzFdISlcbiAgICAgICAgICAudG9JU09TdHJpbmcoKSxcbiAgICAgIH0pXG4gICAgfSlcbiAgICByZXR1cm4gKFxuICAgICAgPD5cbiAgICAgICAgPERhdGVSYW5nZUlucHV0XG4gICAgICAgICAgcmVmPXtyZWZ9XG4gICAgICAgICAgdGltZVBpY2tlclByb3BzPXt7XG4gICAgICAgICAgICB1c2VBbVBtOiB1c2VyLmdldEFtUG1EaXNwbGF5KCksXG4gICAgICAgICAgfX1cbiAgICAgICAgICBhbGxvd1NpbmdsZURheVJhbmdlXG4gICAgICAgICAgbWluRGF0ZT17RGVmYXVsdE1pbkRhdGV9XG4gICAgICAgICAgbWF4RGF0ZT17RGVmYXVsdE1heERhdGV9XG4gICAgICAgICAgZW5kSW5wdXRQcm9wcz17e1xuICAgICAgICAgICAgZmlsbDogdHJ1ZSxcbiAgICAgICAgICAgIGNsYXNzTmFtZTogTXVpT3V0bGluZWRJbnB1dEJvcmRlckNsYXNzZXMsXG4gICAgICAgICAgICAuLi5FbnRlcktleVN1Ym1pdFByb3BzLFxuICAgICAgICAgIH19XG4gICAgICAgICAgc3RhcnRJbnB1dFByb3BzPXt7XG4gICAgICAgICAgICBmaWxsOiB0cnVlLFxuICAgICAgICAgICAgY2xhc3NOYW1lOiBNdWlPdXRsaW5lZElucHV0Qm9yZGVyQ2xhc3NlcyxcbiAgICAgICAgICAgIC4uLkVudGVyS2V5U3VibWl0UHJvcHMsXG4gICAgICAgICAgfX1cbiAgICAgICAgICBjbGFzc05hbWU9XCJ3aGVyZVwiXG4gICAgICAgICAgY2xvc2VPblNlbGVjdGlvbj17ZmFsc2V9XG4gICAgICAgICAgZm9ybWF0RGF0ZT17RGF0ZUhlbHBlcnMuQmx1ZXByaW50LmNvbW1vblByb3BzLmZvcm1hdERhdGV9XG4gICAgICAgICAgb25DaGFuZ2U9e0RhdGVIZWxwZXJzLkJsdWVwcmludC5EYXRlUmFuZ2VQcm9wcy5nZW5lcmF0ZU9uQ2hhbmdlKFxuICAgICAgICAgICAgKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgIHNldExvY2FsVmFsdWUodmFsdWUpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgKX1cbiAgICAgICAgICBwb3BvdmVyUHJvcHM9e3tcbiAgICAgICAgICAgIGJvdW5kYXJ5OiAndmlld3BvcnQnLFxuICAgICAgICAgICAgcG9zaXRpb246ICdib3R0b20nLFxuICAgICAgICAgIH19XG4gICAgICAgICAgcGFyc2VEYXRlPXtEYXRlSGVscGVycy5CbHVlcHJpbnQuY29tbW9uUHJvcHMucGFyc2VEYXRlfVxuICAgICAgICAgIHNob3J0Y3V0c1xuICAgICAgICAgIHRpbWVQcmVjaXNpb249e0RhdGVIZWxwZXJzLkdlbmVyYWwuZ2V0VGltZVByZWNpc2lvbigpfVxuICAgICAgICAgIHBsYWNlaG9sZGVyPXtEYXRlSGVscGVycy5HZW5lcmFsLmdldERhdGVGb3JtYXQoKX1cbiAgICAgICAgICB2YWx1ZT17RGF0ZUhlbHBlcnMuQmx1ZXByaW50LkRhdGVSYW5nZVByb3BzLmdlbmVyYXRlVmFsdWUobG9jYWxWYWx1ZSl9XG4gICAgICAgICAgey4uLkJQRGF0ZVJhbmdlUHJvcHN9XG4gICAgICAgIC8+XG4gICAgICAgIHtoYXNWYWxpZGF0aW9uSXNzdWVzID8gKFxuICAgICAgICAgIDw+XG4gICAgICAgICAgICA8Rm9ybUhlbHBlclRleHQgY2xhc3NOYW1lPVwicHgtMiBNdWktdGV4dC1lcnJvclwiPlxuICAgICAgICAgICAgICB7Y29uc3RydWN0ZWRWYWxpZGF0aW9uVGV4dH1cbiAgICAgICAgICAgIDwvRm9ybUhlbHBlclRleHQ+XG4gICAgICAgICAgPC8+XG4gICAgICAgICkgOiBudWxsfVxuICAgICAgPC8+XG4gICAgKVxuICB9XG4pXG5cbi8qKlxuICogIEJ5IHVwZGF0aW5nIGludmFsaWQgc3RhcnRpbmcgdmFsdWVzIGJlZm9yZSB3ZSBnbyBpbnRvIHRoZSBhYm92ZSBjb21wb25lbnQsIHdlIGNhbiBtYWtlIHN1cmUgd2UgYWx3YXlzIGhhdmUgYSB2YWxpZCB2YWx1ZSB0byBmYWxsIGJhY2sgdG8uXG4gKi9cbmV4cG9ydCBjb25zdCBEYXRlUmFuZ2VGaWVsZCA9IFJlYWN0LmZvcndhcmRSZWYoXG4gIChcbiAgICB7IHZhbHVlLCBvbkNoYW5nZSwgQlBEYXRlUmFuZ2VQcm9wcyB9OiBQcm9wcyxcbiAgICByZWY6IFJlYWN0LlJlZjxEYXRlUmFuZ2VJbnB1dD5cbiAgKSA9PiB7XG4gICAgdXNlSW5pdGlhbFZhbHVlVmFsaWRhdGlvbih7IHZhbHVlLCBvbkNoYW5nZSwgQlBEYXRlUmFuZ2VQcm9wcyB9KVxuICAgIGNvbnN0IHZhbHVlVmFsaWRpdHkgPSBpc1ZhbGlkVmFsdWUodmFsdWUpXG4gICAgaWYgKCF2YWx1ZVZhbGlkaXR5LnZhbGlkKSB7XG4gICAgICByZXR1cm4gPExpbmVhclByb2dyZXNzIGNsYXNzTmFtZT1cInctZnVsbCBoLTJcIiAvPlxuICAgIH1cbiAgICByZXR1cm4gKFxuICAgICAgPERhdGVSYW5nZUZpZWxkV2l0aG91dEluaXRpYWxWYWxpZGF0aW9uXG4gICAgICAgIHJlZj17cmVmfVxuICAgICAgICB2YWx1ZT17dmFsdWV9XG4gICAgICAgIG9uQ2hhbmdlPXtvbkNoYW5nZX1cbiAgICAgICAgQlBEYXRlUmFuZ2VQcm9wcz17QlBEYXRlUmFuZ2VQcm9wc31cbiAgICAgIC8+XG4gICAgKVxuICB9XG4pXG4iXX0=