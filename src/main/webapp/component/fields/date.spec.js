import { __read } from "tslib";
import React from 'react';
import Enzyme, { mount } from 'enzyme';
import Adapter from '@wojtekmaj/enzyme-adapter-react-17';
Enzyme.configure({ adapter: new Adapter() });
import { DateField } from './date';
import moment from 'moment';
import { expect } from 'chai';
import user from '../singletons/user-instance';
import { DateHelpers, ISO_8601_FORMAT_ZONED } from './date-helpers';
import Common from '../../js/Common';
/**
 * Useful for seeing if updates are called correctly.
 */
var UncontrolledDateField = function (_a) {
    var startingValue = _a.startingValue;
    var _b = __read(React.useState(startingValue), 2), value = _b[0], setValue = _b[1];
    return (React.createElement(DateField, { value: value, onChange: function (update) {
            setValue(update);
        }, BPDateProps: {
            inputProps: {
                name: 'test',
            },
        } }));
};
// rely on static data when possible, but in these we can use the DateHelpers (a must for shifted date timezone testing)
var data = {
    date1: {
        timezone: 'America/St_Johns',
        originalISO: '2021-01-15T06:53:54.316Z',
        originalDate: new Date('2021-01-15T06:53:54.316Z'),
        utcISOMinutes: '2021-01-15T06:53:00.000Z',
        userFormatISO: {
            millisecond: '2021-01-15T03:23:54.316-03:30',
            second: '2021-01-15T03:23:54-03:30',
            minute: '2021-01-15T03:23-03:30',
        },
        userFormat24: {
            millisecond: '15 Jan 2021 03:23:54.316 -03:30',
            second: '15 Jan 2021 03:23:54 -03:30',
            minute: '15 Jan 2021 03:23 -03:30',
        },
        userFormat12: {
            millisecond: '15 Jan 2021 03:23:54.316 am -03:30',
            second: '15 Jan 2021 03:23:54 am -03:30',
            minute: '15 Jan 2021 03:23 am -03:30',
        },
    },
    date2: {
        timezone: 'America/St_Johns',
        userSuppliedInput: '15 Jan 2021 03:24:54.316 -02:30',
        parsedOutput: '15 Jan 2021 02:24:54.316 -03:30',
    },
    date3: {
        timezone: 'Etc/UTC',
        maxFuture: moment().add(10, 'years').toISOString(),
        disallowedFuture: moment().add(11, 'years').toISOString(),
    },
    // this is useful for testing daylist savings (date 1 is pre, this is post)
    date4: {
        timezone: 'America/St_Johns',
        originalISO: '2021-04-15T05:53:54.316Z',
    },
};
var wrapper;
describe('verify date field works', function () {
    before(function () {
        user.get('user').get('preferences').set('timeZone', data.date1.timezone);
    });
    after(function () {
        user.get('user').get('preferences').set('timeZone', 'Etc/UTC');
    });
    beforeEach(function () {
        user
            .get('user')
            .get('preferences')
            .set('dateTimeFormat', Common.getDateTimeFormats()['ISO']['millisecond']);
    });
    afterEach(function () {
        // Must unmount to stop listening to the user prefs model (the useTimePrefs() hook)
        // Has to be unmounted before we set any preferences so we don't trigger any onChange
        // callbacks again.
        wrapper.unmount();
        user
            .get('user')
            .get('preferences')
            .set('dateTimeFormat', Common.getDateTimeFormats()['ISO']['millisecond']);
    });
    var verifyDateRender = function (format, precision, expected) {
        return function () {
            user
                .get('user')
                .get('preferences')
                .set('dateTimeFormat', Common.getDateTimeFormats()[format][precision]);
            wrapper = mount(React.createElement(DateField, { value: data.date1.originalISO, onChange: function () { } }));
            expect(wrapper.render().find('input').val()).to.equal(expected);
        };
    };
    it('should render with ISO format and millisecond precision', verifyDateRender('ISO', 'millisecond', data.date1.userFormatISO.millisecond));
    it('should render with ISO format and second precision', verifyDateRender('ISO', 'second', data.date1.userFormatISO.second));
    it('should render with ISO format and minute precision', verifyDateRender('ISO', 'minute', data.date1.userFormatISO.minute));
    it('should render with 24hr format and millisecond precision', verifyDateRender('24', 'millisecond', data.date1.userFormat24.millisecond));
    it('should render with 24hr format and second precision', verifyDateRender('24', 'second', data.date1.userFormat24.second));
    it('should render with 24hr format and minute precision', verifyDateRender('24', 'minute', data.date1.userFormat24.minute));
    it('should render with 12hr format and millisecond precision', verifyDateRender('12', 'millisecond', data.date1.userFormat12.millisecond));
    it('should render with 12hr format and second precision', verifyDateRender('12', 'second', data.date1.userFormat12.second));
    it('should render with 12hr format and minute precision', verifyDateRender('12', 'minute', data.date1.userFormat12.minute));
    it("should parse with user's pref timezone", function () {
        // gist is user enters a time in a diff time from their pref, on blur we adjust it to their preference
        user
            .get('user')
            .get('preferences')
            .set('dateTimeFormat', Common.getDateTimeFormats()['24']['millisecond']);
        wrapper = mount(React.createElement(UncontrolledDateField, { startingValue: data.date1.originalISO }));
        var input = wrapper.find('input').at(0);
        input.simulate('change', {
            target: { value: data.date2.userSuppliedInput },
        });
        expect(input.render().val()).to.equal(data.date2.parsedOutput);
    });
    it("should generate appropriately shifted ISO strings on change (DST)", function () {
        wrapper = mount(React.createElement(DateField, { value: new Date().toISOString(), onChange: function (updatedValue) {
                expect(updatedValue).to.equal(data.date4.originalISO);
            } }));
        var dateFieldInstance = wrapper.children().get(0);
        dateFieldInstance.props.onChange(DateHelpers.Blueprint.converters.TimeshiftForDatePicker(data.date4.originalISO, ISO_8601_FORMAT_ZONED), true);
    });
    it("should generate appropriately shifted ISO strings on change", function () {
        wrapper = mount(React.createElement(DateField, { value: new Date().toISOString(), onChange: function (updatedValue) {
                expect(updatedValue).to.equal(data.date1.originalISO);
            } }));
        var dateFieldInstance = wrapper.children().get(0);
        dateFieldInstance.props.onChange(DateHelpers.Blueprint.converters.TimeshiftForDatePicker(data.date1.originalISO, ISO_8601_FORMAT_ZONED), true);
    });
    it("should not allow dates beyond max future", function () {
        wrapper = mount(React.createElement(DateField, { value: new Date().toISOString(), onChange: function (updatedValue) {
                expect(updatedValue).to.not.equal(data.date3.maxFuture);
            } }));
        var input = wrapper.find('input').at(0);
        input.simulate('change', {
            target: { value: data.date3.disallowedFuture },
        });
    });
    it("should allow dates up to max future", function () {
        wrapper = mount(React.createElement(DateField, { value: new Date().toISOString(), onChange: function (updatedValue) {
                expect(updatedValue).to.equal(data.date3.maxFuture);
            } }));
        var input = wrapper.find('input').at(0);
        input.simulate('change', {
            target: { value: data.date3.maxFuture },
        });
    });
    it('calls onChange with updated value when precision changes', function () {
        wrapper = mount(React.createElement(DateField, { value: data.date1.userFormatISO.millisecond, onChange: function (updatedValue) {
                expect(updatedValue).to.equal(data.date1.utcISOMinutes);
            } }));
        user
            .get('user')
            .get('preferences')
            .set('dateTimeFormat', Common.getDateTimeFormats()['ISO']['minute']);
    });
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGF0ZS5zcGVjLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vc3JjL21haW4vd2ViYXBwL2NvbXBvbmVudC9maWVsZHMvZGF0ZS5zcGVjLnRzeCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUEsT0FBTyxLQUFLLE1BQU0sT0FBTyxDQUFBO0FBQ3pCLE9BQU8sTUFBTSxFQUFFLEVBQUUsS0FBSyxFQUFFLE1BQU0sUUFBUSxDQUFBO0FBQ3RDLE9BQU8sT0FBTyxNQUFNLG9DQUFvQyxDQUFBO0FBQ3hELE1BQU0sQ0FBQyxTQUFTLENBQUMsRUFBRSxPQUFPLEVBQUUsSUFBSSxPQUFPLEVBQUUsRUFBRSxDQUFDLENBQUE7QUFFNUMsT0FBTyxFQUFFLFNBQVMsRUFBRSxNQUFNLFFBQVEsQ0FBQTtBQUNsQyxPQUFPLE1BQU0sTUFBTSxRQUFRLENBQUE7QUFDM0IsT0FBTyxFQUFFLE1BQU0sRUFBRSxNQUFNLE1BQU0sQ0FBQTtBQUU3QixPQUFPLElBQUksTUFBTSw2QkFBNkIsQ0FBQTtBQUM5QyxPQUFPLEVBQUUsV0FBVyxFQUFFLHFCQUFxQixFQUFFLE1BQU0sZ0JBQWdCLENBQUE7QUFDbkUsT0FBTyxNQUFNLE1BQU0saUJBQWlCLENBQUE7QUFHcEM7O0dBRUc7QUFDSCxJQUFNLHFCQUFxQixHQUFHLFVBQUMsRUFJOUI7UUFIQyxhQUFhLG1CQUFBO0lBSVAsSUFBQSxLQUFBLE9BQW9CLEtBQUssQ0FBQyxRQUFRLENBQUMsYUFBYSxDQUFDLElBQUEsRUFBaEQsS0FBSyxRQUFBLEVBQUUsUUFBUSxRQUFpQyxDQUFBO0lBQ3ZELE9BQU8sQ0FDTCxvQkFBQyxTQUFTLElBQ1IsS0FBSyxFQUFFLEtBQUssRUFDWixRQUFRLEVBQUUsVUFBQyxNQUFNO1lBQ2YsUUFBUSxDQUFDLE1BQU0sQ0FBQyxDQUFBO1FBQ2xCLENBQUMsRUFDRCxXQUFXLEVBQUU7WUFDWCxVQUFVLEVBQUU7Z0JBQ1YsSUFBSSxFQUFFLE1BQU07YUFDYjtTQUNG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Q0FBQyxHQUNELENBQ0gsQ0FBQTtRQUNELElBQU0sS0FBSyxHQUFHLE9BQU8sQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFBO1FBQ3pDLEtBQUssQ0FBQyxRQUFRLENBQUMsUUFBUSxFQUFFO1lBQ3ZCLE1BQU0sRUFBRSxFQUFFLEtBQUssRUFBRSxJQUFJLENBQUMsS0FBSyxDQUFDLFNBQVMsRUFBRTtTQUN4QyxDQUFDLENBQUE7SUFDSixDQUFDLENBQUMsQ0FBQTtJQUNGLEVBQUUsQ0FBQywwREFBMEQsRUFBRTtRQUM3RCxPQUFPLEdBQUcsS0FBSyxDQUNiLG9CQUFDLFNBQVMsSUFDUixLQUFLLEVBQUUsSUFBSSxDQUFDLEtBQUssQ0FBQyxhQUFhLENBQUMsV0FBVyxFQUMzQyxRQUFRLEVBQUUsVUFBQyxZQUFZO2dCQUNyQixNQUFNLENBQUMsWUFBWSxDQUFDLENBQUMsRUFBRSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLGFBQWEsQ0FBQyxDQUFBO1lBQ3pELENBQUMsR0FDRCxDQUNILENBQUE7UUFDRCxJQUFJO2FBQ0QsR0FBRyxDQUFDLE1BQU0sQ0FBQzthQUNYLEdBQUcsQ0FBQyxhQUFhLENBQUM7YUFDbEIsR0FBRyxDQUFDLGdCQUFnQixFQUFFLE1BQU0sQ0FBQyxrQkFBa0IsRUFBRSxDQUFDLEtBQUssQ0FBQyxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUE7SUFDeEUsQ0FBQyxDQUFDLENBQUE7QUFDSixDQUFDLENBQUMsQ0FBQSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCdcbmltcG9ydCBFbnp5bWUsIHsgbW91bnQgfSBmcm9tICdlbnp5bWUnXG5pbXBvcnQgQWRhcHRlciBmcm9tICdAd29qdGVrbWFqL2VuenltZS1hZGFwdGVyLXJlYWN0LTE3J1xuRW56eW1lLmNvbmZpZ3VyZSh7IGFkYXB0ZXI6IG5ldyBBZGFwdGVyKCkgfSlcblxuaW1wb3J0IHsgRGF0ZUZpZWxkIH0gZnJvbSAnLi9kYXRlJ1xuaW1wb3J0IG1vbWVudCBmcm9tICdtb21lbnQnXG5pbXBvcnQgeyBleHBlY3QgfSBmcm9tICdjaGFpJ1xuXG5pbXBvcnQgdXNlciBmcm9tICcuLi9zaW5nbGV0b25zL3VzZXItaW5zdGFuY2UnXG5pbXBvcnQgeyBEYXRlSGVscGVycywgSVNPXzg2MDFfRk9STUFUX1pPTkVEIH0gZnJvbSAnLi9kYXRlLWhlbHBlcnMnXG5pbXBvcnQgQ29tbW9uIGZyb20gJy4uLy4uL2pzL0NvbW1vbidcbmltcG9ydCB7IFRpbWVQcmVjaXNpb24gfSBmcm9tICdAYmx1ZXByaW50anMvZGF0ZXRpbWUnXG5cbi8qKlxuICogVXNlZnVsIGZvciBzZWVpbmcgaWYgdXBkYXRlcyBhcmUgY2FsbGVkIGNvcnJlY3RseS5cbiAqL1xuY29uc3QgVW5jb250cm9sbGVkRGF0ZUZpZWxkID0gKHtcbiAgc3RhcnRpbmdWYWx1ZSxcbn06IHtcbiAgc3RhcnRpbmdWYWx1ZTogc3RyaW5nXG59KSA9PiB7XG4gIGNvbnN0IFt2YWx1ZSwgc2V0VmFsdWVdID0gUmVhY3QudXNlU3RhdGUoc3RhcnRpbmdWYWx1ZSlcbiAgcmV0dXJuIChcbiAgICA8RGF0ZUZpZWxkXG4gICAgICB2YWx1ZT17dmFsdWV9XG4gICAgICBvbkNoYW5nZT17KHVwZGF0ZSkgPT4ge1xuICAgICAgICBzZXRWYWx1ZSh1cGRhdGUpXG4gICAgICB9fVxuICAgICAgQlBEYXRlUHJvcHM9e3tcbiAgICAgICAgaW5wdXRQcm9wczoge1xuICAgICAgICAgIG5hbWU6ICd0ZXN0JyxcbiAgICAgICAgfSxcbiAgICAgIH19XG4gICAgLz5cbiAgKVxufVxuXG4vLyByZWx5IG9uIHN0YXRpYyBkYXRhIHdoZW4gcG9zc2libGUsIGJ1dCBpbiB0aGVzZSB3ZSBjYW4gdXNlIHRoZSBEYXRlSGVscGVycyAoYSBtdXN0IGZvciBzaGlmdGVkIGRhdGUgdGltZXpvbmUgdGVzdGluZylcbmNvbnN0IGRhdGEgPSB7XG4gIGRhdGUxOiB7XG4gICAgdGltZXpvbmU6ICdBbWVyaWNhL1N0X0pvaG5zJyxcbiAgICBvcmlnaW5hbElTTzogJzIwMjEtMDEtMTVUMDY6NTM6NTQuMzE2WicsXG4gICAgb3JpZ2luYWxEYXRlOiBuZXcgRGF0ZSgnMjAyMS0wMS0xNVQwNjo1Mzo1NC4zMTZaJyksXG4gICAgdXRjSVNPTWludXRlczogJzIwMjEtMDEtMTVUMDY6NTM6MDAuMDAwWicsXG4gICAgdXNlckZvcm1hdElTTzoge1xuICAgICAgbWlsbGlzZWNvbmQ6ICcyMDIxLTAxLTE1VDAzOjIzOjU0LjMxNi0wMzozMCcsXG4gICAgICBzZWNvbmQ6ICcyMDIxLTAxLTE1VDAzOjIzOjU0LTAzOjMwJyxcbiAgICAgIG1pbnV0ZTogJzIwMjEtMDEtMTVUMDM6MjMtMDM6MzAnLFxuICAgIH0sXG4gICAgdXNlckZvcm1hdDI0OiB7XG4gICAgICBtaWxsaXNlY29uZDogJzE1IEphbiAyMDIxIDAzOjIzOjU0LjMxNiAtMDM6MzAnLFxuICAgICAgc2Vjb25kOiAnMTUgSmFuIDIwMjEgMDM6MjM6NTQgLTAzOjMwJyxcbiAgICAgIG1pbnV0ZTogJzE1IEphbiAyMDIxIDAzOjIzIC0wMzozMCcsXG4gICAgfSxcbiAgICB1c2VyRm9ybWF0MTI6IHtcbiAgICAgIG1pbGxpc2Vjb25kOiAnMTUgSmFuIDIwMjEgMDM6MjM6NTQuMzE2IGFtIC0wMzozMCcsXG4gICAgICBzZWNvbmQ6ICcxNSBKYW4gMjAyMSAwMzoyMzo1NCBhbSAtMDM6MzAnLFxuICAgICAgbWludXRlOiAnMTUgSmFuIDIwMjEgMDM6MjMgYW0gLTAzOjMwJyxcbiAgICB9LFxuICB9LFxuICBkYXRlMjoge1xuICAgIHRpbWV6b25lOiAnQW1lcmljYS9TdF9Kb2hucycsXG4gICAgdXNlclN1cHBsaWVkSW5wdXQ6ICcxNSBKYW4gMjAyMSAwMzoyNDo1NC4zMTYgLTAyOjMwJyxcbiAgICBwYXJzZWRPdXRwdXQ6ICcxNSBKYW4gMjAyMSAwMjoyNDo1NC4zMTYgLTAzOjMwJyxcbiAgfSxcbiAgZGF0ZTM6IHtcbiAgICB0aW1lem9uZTogJ0V0Yy9VVEMnLFxuICAgIG1heEZ1dHVyZTogbW9tZW50KCkuYWRkKDEwLCAneWVhcnMnKS50b0lTT1N0cmluZygpLFxuICAgIGRpc2FsbG93ZWRGdXR1cmU6IG1vbWVudCgpLmFkZCgxMSwgJ3llYXJzJykudG9JU09TdHJpbmcoKSxcbiAgfSxcbiAgLy8gdGhpcyBpcyB1c2VmdWwgZm9yIHRlc3RpbmcgZGF5bGlzdCBzYXZpbmdzIChkYXRlIDEgaXMgcHJlLCB0aGlzIGlzIHBvc3QpXG4gIGRhdGU0OiB7XG4gICAgdGltZXpvbmU6ICdBbWVyaWNhL1N0X0pvaG5zJyxcbiAgICBvcmlnaW5hbElTTzogJzIwMjEtMDQtMTVUMDU6NTM6NTQuMzE2WicsXG4gIH0sXG59XG5sZXQgd3JhcHBlcjogRW56eW1lLlJlYWN0V3JhcHBlclxuZGVzY3JpYmUoJ3ZlcmlmeSBkYXRlIGZpZWxkIHdvcmtzJywgKCkgPT4ge1xuICBiZWZvcmUoKCkgPT4ge1xuICAgIHVzZXIuZ2V0KCd1c2VyJykuZ2V0KCdwcmVmZXJlbmNlcycpLnNldCgndGltZVpvbmUnLCBkYXRhLmRhdGUxLnRpbWV6b25lKVxuICB9KVxuICBhZnRlcigoKSA9PiB7XG4gICAgdXNlci5nZXQoJ3VzZXInKS5nZXQoJ3ByZWZlcmVuY2VzJykuc2V0KCd0aW1lWm9uZScsICdFdGMvVVRDJylcbiAgfSlcbiAgYmVmb3JlRWFjaCgoKSA9PiB7XG4gICAgdXNlclxuICAgICAgLmdldCgndXNlcicpXG4gICAgICAuZ2V0KCdwcmVmZXJlbmNlcycpXG4gICAgICAuc2V0KCdkYXRlVGltZUZvcm1hdCcsIENvbW1vbi5nZXREYXRlVGltZUZvcm1hdHMoKVsnSVNPJ11bJ21pbGxpc2Vjb25kJ10pXG4gIH0pXG4gIGFmdGVyRWFjaCgoKSA9PiB7XG4gICAgLy8gTXVzdCB1bm1vdW50IHRvIHN0b3AgbGlzdGVuaW5nIHRvIHRoZSB1c2VyIHByZWZzIG1vZGVsICh0aGUgdXNlVGltZVByZWZzKCkgaG9vaylcbiAgICAvLyBIYXMgdG8gYmUgdW5tb3VudGVkIGJlZm9yZSB3ZSBzZXQgYW55IHByZWZlcmVuY2VzIHNvIHdlIGRvbid0IHRyaWdnZXIgYW55IG9uQ2hhbmdlXG4gICAgLy8gY2FsbGJhY2tzIGFnYWluLlxuICAgIHdyYXBwZXIudW5tb3VudCgpXG4gICAgdXNlclxuICAgICAgLmdldCgndXNlcicpXG4gICAgICAuZ2V0KCdwcmVmZXJlbmNlcycpXG4gICAgICAuc2V0KCdkYXRlVGltZUZvcm1hdCcsIENvbW1vbi5nZXREYXRlVGltZUZvcm1hdHMoKVsnSVNPJ11bJ21pbGxpc2Vjb25kJ10pXG4gIH0pXG4gIGNvbnN0IHZlcmlmeURhdGVSZW5kZXIgPSAoXG4gICAgZm9ybWF0OiBzdHJpbmcsXG4gICAgcHJlY2lzaW9uOiBUaW1lUHJlY2lzaW9uLFxuICAgIGV4cGVjdGVkOiBzdHJpbmdcbiAgKSA9PiB7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHVzZXJcbiAgICAgICAgLmdldCgndXNlcicpXG4gICAgICAgIC5nZXQoJ3ByZWZlcmVuY2VzJylcbiAgICAgICAgLnNldCgnZGF0ZVRpbWVGb3JtYXQnLCBDb21tb24uZ2V0RGF0ZVRpbWVGb3JtYXRzKClbZm9ybWF0XVtwcmVjaXNpb25dKVxuICAgICAgd3JhcHBlciA9IG1vdW50KFxuICAgICAgICA8RGF0ZUZpZWxkIHZhbHVlPXtkYXRhLmRhdGUxLm9yaWdpbmFsSVNPfSBvbkNoYW5nZT17KCkgPT4ge319IC8+XG4gICAgICApXG4gICAgICBleHBlY3Qod3JhcHBlci5yZW5kZXIoKS5maW5kKCdpbnB1dCcpLnZhbCgpKS50by5lcXVhbChleHBlY3RlZClcbiAgICB9XG4gIH1cbiAgaXQoXG4gICAgJ3Nob3VsZCByZW5kZXIgd2l0aCBJU08gZm9ybWF0IGFuZCBtaWxsaXNlY29uZCBwcmVjaXNpb24nLFxuICAgIHZlcmlmeURhdGVSZW5kZXIoJ0lTTycsICdtaWxsaXNlY29uZCcsIGRhdGEuZGF0ZTEudXNlckZvcm1hdElTTy5taWxsaXNlY29uZClcbiAgKVxuICBpdChcbiAgICAnc2hvdWxkIHJlbmRlciB3aXRoIElTTyBmb3JtYXQgYW5kIHNlY29uZCBwcmVjaXNpb24nLFxuICAgIHZlcmlmeURhdGVSZW5kZXIoJ0lTTycsICdzZWNvbmQnLCBkYXRhLmRhdGUxLnVzZXJGb3JtYXRJU08uc2Vjb25kKVxuICApXG4gIGl0KFxuICAgICdzaG91bGQgcmVuZGVyIHdpdGggSVNPIGZvcm1hdCBhbmQgbWludXRlIHByZWNpc2lvbicsXG4gICAgdmVyaWZ5RGF0ZVJlbmRlcignSVNPJywgJ21pbnV0ZScsIGRhdGEuZGF0ZTEudXNlckZvcm1hdElTTy5taW51dGUpXG4gIClcbiAgaXQoXG4gICAgJ3Nob3VsZCByZW5kZXIgd2l0aCAyNGhyIGZvcm1hdCBhbmQgbWlsbGlzZWNvbmQgcHJlY2lzaW9uJyxcbiAgICB2ZXJpZnlEYXRlUmVuZGVyKCcyNCcsICdtaWxsaXNlY29uZCcsIGRhdGEuZGF0ZTEudXNlckZvcm1hdDI0Lm1pbGxpc2Vjb25kKVxuICApXG4gIGl0KFxuICAgICdzaG91bGQgcmVuZGVyIHdpdGggMjRociBmb3JtYXQgYW5kIHNlY29uZCBwcmVjaXNpb24nLFxuICAgIHZlcmlmeURhdGVSZW5kZXIoJzI0JywgJ3NlY29uZCcsIGRhdGEuZGF0ZTEudXNlckZvcm1hdDI0LnNlY29uZClcbiAgKVxuICBpdChcbiAgICAnc2hvdWxkIHJlbmRlciB3aXRoIDI0aHIgZm9ybWF0IGFuZCBtaW51dGUgcHJlY2lzaW9uJyxcbiAgICB2ZXJpZnlEYXRlUmVuZGVyKCcyNCcsICdtaW51dGUnLCBkYXRhLmRhdGUxLnVzZXJGb3JtYXQyNC5taW51dGUpXG4gIClcbiAgaXQoXG4gICAgJ3Nob3VsZCByZW5kZXIgd2l0aCAxMmhyIGZvcm1hdCBhbmQgbWlsbGlzZWNvbmQgcHJlY2lzaW9uJyxcbiAgICB2ZXJpZnlEYXRlUmVuZGVyKCcxMicsICdtaWxsaXNlY29uZCcsIGRhdGEuZGF0ZTEudXNlckZvcm1hdDEyLm1pbGxpc2Vjb25kKVxuICApXG4gIGl0KFxuICAgICdzaG91bGQgcmVuZGVyIHdpdGggMTJociBmb3JtYXQgYW5kIHNlY29uZCBwcmVjaXNpb24nLFxuICAgIHZlcmlmeURhdGVSZW5kZXIoJzEyJywgJ3NlY29uZCcsIGRhdGEuZGF0ZTEudXNlckZvcm1hdDEyLnNlY29uZClcbiAgKVxuICBpdChcbiAgICAnc2hvdWxkIHJlbmRlciB3aXRoIDEyaHIgZm9ybWF0IGFuZCBtaW51dGUgcHJlY2lzaW9uJyxcbiAgICB2ZXJpZnlEYXRlUmVuZGVyKCcxMicsICdtaW51dGUnLCBkYXRhLmRhdGUxLnVzZXJGb3JtYXQxMi5taW51dGUpXG4gIClcbiAgaXQoYHNob3VsZCBwYXJzZSB3aXRoIHVzZXIncyBwcmVmIHRpbWV6b25lYCwgKCkgPT4ge1xuICAgIC8vIGdpc3QgaXMgdXNlciBlbnRlcnMgYSB0aW1lIGluIGEgZGlmZiB0aW1lIGZyb20gdGhlaXIgcHJlZiwgb24gYmx1ciB3ZSBhZGp1c3QgaXQgdG8gdGhlaXIgcHJlZmVyZW5jZVxuICAgIHVzZXJcbiAgICAgIC5nZXQoJ3VzZXInKVxuICAgICAgLmdldCgncHJlZmVyZW5jZXMnKVxuICAgICAgLnNldCgnZGF0ZVRpbWVGb3JtYXQnLCBDb21tb24uZ2V0RGF0ZVRpbWVGb3JtYXRzKClbJzI0J11bJ21pbGxpc2Vjb25kJ10pXG5cbiAgICB3cmFwcGVyID0gbW91bnQoXG4gICAgICA8VW5jb250cm9sbGVkRGF0ZUZpZWxkIHN0YXJ0aW5nVmFsdWU9e2RhdGEuZGF0ZTEub3JpZ2luYWxJU099IC8+XG4gICAgKVxuICAgIGNvbnN0IGlucHV0ID0gd3JhcHBlci5maW5kKCdpbnB1dCcpLmF0KDApXG4gICAgaW5wdXQuc2ltdWxhdGUoJ2NoYW5nZScsIHtcbiAgICAgIHRhcmdldDogeyB2YWx1ZTogZGF0YS5kYXRlMi51c2VyU3VwcGxpZWRJbnB1dCB9LFxuICAgIH0pXG4gICAgZXhwZWN0KGlucHV0LnJlbmRlcigpLnZhbCgpKS50by5lcXVhbChkYXRhLmRhdGUyLnBhcnNlZE91dHB1dClcbiAgfSlcbiAgaXQoYHNob3VsZCBnZW5lcmF0ZSBhcHByb3ByaWF0ZWx5IHNoaWZ0ZWQgSVNPIHN0cmluZ3Mgb24gY2hhbmdlIChEU1QpYCwgKCkgPT4ge1xuICAgIHdyYXBwZXIgPSBtb3VudChcbiAgICAgIDxEYXRlRmllbGRcbiAgICAgICAgdmFsdWU9e25ldyBEYXRlKCkudG9JU09TdHJpbmcoKX1cbiAgICAgICAgb25DaGFuZ2U9eyh1cGRhdGVkVmFsdWUpID0+IHtcbiAgICAgICAgICBleHBlY3QodXBkYXRlZFZhbHVlKS50by5lcXVhbChkYXRhLmRhdGU0Lm9yaWdpbmFsSVNPKVxuICAgICAgICB9fVxuICAgICAgLz5cbiAgICApXG4gICAgY29uc3QgZGF0ZUZpZWxkSW5zdGFuY2UgPSB3cmFwcGVyLmNoaWxkcmVuKCkuZ2V0KDApXG4gICAgZGF0ZUZpZWxkSW5zdGFuY2UucHJvcHMub25DaGFuZ2UoXG4gICAgICBEYXRlSGVscGVycy5CbHVlcHJpbnQuY29udmVydGVycy5UaW1lc2hpZnRGb3JEYXRlUGlja2VyKFxuICAgICAgICBkYXRhLmRhdGU0Lm9yaWdpbmFsSVNPLFxuICAgICAgICBJU09fODYwMV9GT1JNQVRfWk9ORURcbiAgICAgICksXG4gICAgICB0cnVlXG4gICAgKVxuICB9KVxuICBpdChgc2hvdWxkIGdlbmVyYXRlIGFwcHJvcHJpYXRlbHkgc2hpZnRlZCBJU08gc3RyaW5ncyBvbiBjaGFuZ2VgLCAoKSA9PiB7XG4gICAgd3JhcHBlciA9IG1vdW50KFxuICAgICAgPERhdGVGaWVsZFxuICAgICAgICB2YWx1ZT17bmV3IERhdGUoKS50b0lTT1N0cmluZygpfVxuICAgICAgICBvbkNoYW5nZT17KHVwZGF0ZWRWYWx1ZSkgPT4ge1xuICAgICAgICAgIGV4cGVjdCh1cGRhdGVkVmFsdWUpLnRvLmVxdWFsKGRhdGEuZGF0ZTEub3JpZ2luYWxJU08pXG4gICAgICAgIH19XG4gICAgICAvPlxuICAgIClcbiAgICBjb25zdCBkYXRlRmllbGRJbnN0YW5jZSA9IHdyYXBwZXIuY2hpbGRyZW4oKS5nZXQoMClcbiAgICBkYXRlRmllbGRJbnN0YW5jZS5wcm9wcy5vbkNoYW5nZShcbiAgICAgIERhdGVIZWxwZXJzLkJsdWVwcmludC5jb252ZXJ0ZXJzLlRpbWVzaGlmdEZvckRhdGVQaWNrZXIoXG4gICAgICAgIGRhdGEuZGF0ZTEub3JpZ2luYWxJU08sXG4gICAgICAgIElTT184NjAxX0ZPUk1BVF9aT05FRFxuICAgICAgKSxcbiAgICAgIHRydWVcbiAgICApXG4gIH0pXG4gIGl0KGBzaG91bGQgbm90IGFsbG93IGRhdGVzIGJleW9uZCBtYXggZnV0dXJlYCwgKCkgPT4ge1xuICAgIHdyYXBwZXIgPSBtb3VudChcbiAgICAgIDxEYXRlRmllbGRcbiAgICAgICAgdmFsdWU9e25ldyBEYXRlKCkudG9JU09TdHJpbmcoKX1cbiAgICAgICAgb25DaGFuZ2U9eyh1cGRhdGVkVmFsdWUpID0+IHtcbiAgICAgICAgICBleHBlY3QodXBkYXRlZFZhbHVlKS50by5ub3QuZXF1YWwoZGF0YS5kYXRlMy5tYXhGdXR1cmUpXG4gICAgICAgIH19XG4gICAgICAvPlxuICAgIClcbiAgICBjb25zdCBpbnB1dCA9IHdyYXBwZXIuZmluZCgnaW5wdXQnKS5hdCgwKVxuICAgIGlucHV0LnNpbXVsYXRlKCdjaGFuZ2UnLCB7XG4gICAgICB0YXJnZXQ6IHsgdmFsdWU6IGRhdGEuZGF0ZTMuZGlzYWxsb3dlZEZ1dHVyZSB9LFxuICAgIH0pXG4gIH0pXG4gIGl0KGBzaG91bGQgYWxsb3cgZGF0ZXMgdXAgdG8gbWF4IGZ1dHVyZWAsICgpID0+IHtcbiAgICB3cmFwcGVyID0gbW91bnQoXG4gICAgICA8RGF0ZUZpZWxkXG4gICAgICAgIHZhbHVlPXtuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCl9XG4gICAgICAgIG9uQ2hhbmdlPXsodXBkYXRlZFZhbHVlKSA9PiB7XG4gICAgICAgICAgZXhwZWN0KHVwZGF0ZWRWYWx1ZSkudG8uZXF1YWwoZGF0YS5kYXRlMy5tYXhGdXR1cmUpXG4gICAgICAgIH19XG4gICAgICAvPlxuICAgIClcbiAgICBjb25zdCBpbnB1dCA9IHdyYXBwZXIuZmluZCgnaW5wdXQnKS5hdCgwKVxuICAgIGlucHV0LnNpbXVsYXRlKCdjaGFuZ2UnLCB7XG4gICAgICB0YXJnZXQ6IHsgdmFsdWU6IGRhdGEuZGF0ZTMubWF4RnV0dXJlIH0sXG4gICAgfSlcbiAgfSlcbiAgaXQoJ2NhbGxzIG9uQ2hhbmdlIHdpdGggdXBkYXRlZCB2YWx1ZSB3aGVuIHByZWNpc2lvbiBjaGFuZ2VzJywgKCkgPT4ge1xuICAgIHdyYXBwZXIgPSBtb3VudChcbiAgICAgIDxEYXRlRmllbGRcbiAgICAgICAgdmFsdWU9e2RhdGEuZGF0ZTEudXNlckZvcm1hdElTTy5taWxsaXNlY29uZH1cbiAgICAgICAgb25DaGFuZ2U9eyh1cGRhdGVkVmFsdWUpID0+IHtcbiAgICAgICAgICBleHBlY3QodXBkYXRlZFZhbHVlKS50by5lcXVhbChkYXRhLmRhdGUxLnV0Y0lTT01pbnV0ZXMpXG4gICAgICAgIH19XG4gICAgICAvPlxuICAgIClcbiAgICB1c2VyXG4gICAgICAuZ2V0KCd1c2VyJylcbiAgICAgIC5nZXQoJ3ByZWZlcmVuY2VzJylcbiAgICAgIC5zZXQoJ2RhdGVUaW1lRm9ybWF0JywgQ29tbW9uLmdldERhdGVUaW1lRm9ybWF0cygpWydJU08nXVsnbWludXRlJ10pXG4gIH0pXG59KVxuIl19