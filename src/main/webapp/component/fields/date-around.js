import { __assign } from "tslib";
import { jsx as _jsx, jsxs as _jsxs } from "react/jsx-runtime";
/**
 * Copyright (c) Codice Foundation
 *
 * This is free software: you can redistribute it and/or modify it under the terms of the GNU Lesser
 * General Public License as published by the Free Software Foundation, either version 3 of the
 * License, or any later version.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without
 * even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details. A copy of the GNU Lesser General Public License
 * is distributed along with this program and can be found at
 * <http://www.gnu.org/licenses/lgpl.html>.
 *
 **/
import * as React from 'react';
import { DateInput } from '@blueprintjs/datetime';
import { DateHelpers, DefaultMaxDate, DefaultMinDate } from './date-helpers';
import { MuiOutlinedInputBorderClasses } from '../theme/theme';
import useTimePrefs from './useTimePrefs';
import Grid from '@mui/material/Grid/Grid';
import { NumberField } from './number';
import TextField from '@mui/material/TextField/TextField';
import MenuItem from '@mui/material/MenuItem/MenuItem';
import user from '../singletons/user-instance';
import { EnterKeySubmitProps } from '../custom-events/enter-key-submit';
var defaultValue = function () {
    return {
        date: new Date().toISOString(),
        buffer: {
            amount: '1',
            unit: 'd',
        },
        direction: 'both',
    };
};
var validateDate = function (_a) {
    var value = _a.value, onChange = _a.onChange;
    if (!value.date ||
        !value.buffer ||
        !value.direction ||
        DateHelpers.Blueprint.commonProps.parseDate(value.date) === null) {
        var newDate = DateHelpers.General.withPrecision(new Date());
        onChange(__assign(__assign({}, defaultValue()), { date: newDate.toISOString() }));
    }
};
export var DateAroundField = function (_a) {
    var value = _a.value, onChange = _a.onChange;
    var validValue = __assign(__assign({}, defaultValue()), value);
    var blueprintDateRef = React.useRef(null);
    useTimePrefs(function () {
        var shiftedDate = DateHelpers.Blueprint.DateProps.generateValue(value.date);
        var unshiftedDate = DateHelpers.Blueprint.converters.UntimeshiftFromDatePicker(shiftedDate);
        onChange(__assign(__assign({}, validValue), { date: unshiftedDate.toISOString() }));
    });
    React.useEffect(function () {
        validateDate({ onChange: onChange, value: value });
    }, []);
    return (_jsxs(Grid, { container: true, alignItems: "stretch", direction: "column", wrap: "nowrap", children: [_jsx(Grid, { item: true, className: "w-full pb-2", children: _jsx(DateInput, { ref: blueprintDateRef, timePickerProps: {
                        useAmPm: user.getAmPmDisplay(),
                    }, className: MuiOutlinedInputBorderClasses, minDate: DefaultMinDate, maxDate: DefaultMaxDate, closeOnSelection: false, fill: true, formatDate: DateHelpers.Blueprint.commonProps.formatDate, onChange: DateHelpers.Blueprint.DateProps.generateOnChange(function (date) {
                        onChange(__assign(__assign({}, validValue), { date: date }));
                    }), parseDate: DateHelpers.Blueprint.commonProps.parseDate, placeholder: DateHelpers.General.getDateFormat(), shortcuts: true, timePrecision: DateHelpers.General.getTimePrecision(), inputProps: __assign({}, EnterKeySubmitProps), popoverProps: {
                        boundary: 'viewport',
                        position: 'bottom',
                        onClose: function () {
                            setTimeout(function () {
                                var _a;
                                (_a = blueprintDateRef.current) === null || _a === void 0 ? void 0 : _a.setState({ isOpen: false });
                            }, 0);
                        },
                    }, value: DateHelpers.Blueprint.DateProps.generateValue(validValue.date) }) }), _jsx(Grid, { item: true, className: "w-full pb-2", children: "with buffer of" }), _jsxs(Grid, { container: true, direction: "row", className: "w-full", children: [_jsx(Grid, { item: true, xs: 4, className: "pb-2", children: _jsx(NumberField, { type: "float", onChange: function (val) {
                                if (onChange)
                                    onChange(__assign(__assign({}, validValue), { buffer: __assign(__assign({}, validValue.buffer), { amount: val.toString() }) }));
                            }, validation: function (val) { return val > 0; }, validationText: "Must be greater than 0, using previous value of ", value: validValue.buffer.amount }) }), _jsx(Grid, { item: true, xs: 8, className: "pl-2", children: _jsxs(TextField, { fullWidth: true, variant: "outlined", select: true, onChange: function (e) {
                                if (onChange)
                                    onChange(__assign(__assign({}, validValue), { buffer: __assign(__assign({}, validValue.buffer), { unit: e.target
                                                .value }) }));
                            }, size: "small", value: validValue.buffer.unit, children: [_jsx(MenuItem, { value: "s", children: "Seconds" }), _jsx(MenuItem, { value: "m", children: "Minutes" }), _jsx(MenuItem, { value: "h", children: "Hours" }), _jsx(MenuItem, { value: "d", children: "Days" }), _jsx(MenuItem, { value: "w", children: "Weeks" }), _jsx(MenuItem, { value: "M", children: "Months" }), _jsx(MenuItem, { value: "y", children: "Years" })] }) })] }), _jsxs(TextField, { variant: "outlined", select: true, value: validValue.direction, onChange: function (e) {
                    if (onChange)
                        onChange(__assign(__assign({}, validValue), { direction: e.target.value }));
                }, size: "small", children: [_jsx(MenuItem, { value: "both", children: "Before and After" }), _jsx(MenuItem, { value: "before", children: "Before" }), _jsx(MenuItem, { value: "after", children: "After" })] })] }));
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGF0ZS1hcm91bmQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi9zcmMvbWFpbi93ZWJhcHAvY29tcG9uZW50L2ZpZWxkcy9kYXRlLWFyb3VuZC50c3giXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFBQTs7Ozs7Ozs7Ozs7OztJQWFJO0FBQ0osT0FBTyxLQUFLLEtBQUssTUFBTSxPQUFPLENBQUE7QUFDOUIsT0FBTyxFQUFFLFNBQVMsRUFBRSxNQUFNLHVCQUF1QixDQUFBO0FBQ2pELE9BQU8sRUFBRSxXQUFXLEVBQUUsY0FBYyxFQUFFLGNBQWMsRUFBRSxNQUFNLGdCQUFnQixDQUFBO0FBQzVFLE9BQU8sRUFBRSw2QkFBNkIsRUFBRSxNQUFNLGdCQUFnQixDQUFBO0FBQzlELE9BQU8sWUFBWSxNQUFNLGdCQUFnQixDQUFBO0FBRXpDLE9BQU8sSUFBSSxNQUFNLHlCQUF5QixDQUFBO0FBQzFDLE9BQU8sRUFBRSxXQUFXLEVBQUUsTUFBTSxVQUFVLENBQUE7QUFDdEMsT0FBTyxTQUFTLE1BQU0sbUNBQW1DLENBQUE7QUFDekQsT0FBTyxRQUFRLE1BQU0saUNBQWlDLENBQUE7QUFFdEQsT0FBTyxJQUFJLE1BQU0sNkJBQTZCLENBQUE7QUFDOUMsT0FBTyxFQUFFLG1CQUFtQixFQUFFLE1BQU0sbUNBQW1DLENBQUE7QUFPdkUsSUFBTSxZQUFZLEdBQUc7SUFDbkIsT0FBTztRQUNMLElBQUksRUFBRSxJQUFJLElBQUksRUFBRSxDQUFDLFdBQVcsRUFBRTtRQUM5QixNQUFNLEVBQUU7WUFDTixNQUFNLEVBQUUsR0FBRztZQUNYLElBQUksRUFBRSxHQUFHO1NBQ1Y7UUFDRCxTQUFTLEVBQUUsTUFBTTtLQUNNLENBQUE7QUFDM0IsQ0FBQyxDQUFBO0FBRUQsSUFBTSxZQUFZLEdBQUcsVUFBQyxFQUFvQztRQUFsQyxLQUFLLFdBQUEsRUFBRSxRQUFRLGNBQUE7SUFDckMsSUFDRSxDQUFDLEtBQUssQ0FBQyxJQUFJO1FBQ1gs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QUFDLE1BQU0sQ0FBQyxJQUFJLGFBRTdCLEtBQUMsUUFBUSxJQUFDLEtBQUssRUFBQyxHQUFHLHdCQUFtQixFQUN0QyxLQUFDLFFBQVEsSUFBQyxLQUFLLEVBQUMsR0FBRyx3QkFBbUIsRUFDdEMsS0FBQyxRQUFRLElBQUMsS0FBSyxFQUFDLEdBQUcsc0JBQWlCLEVBQ3BDLEtBQUMsUUFBUSxJQUFDLEtBQUssRUFBQyxHQUFHLHFCQUFnQixFQUNuQyxLQUFDLFFBQVEsSUFBQyxLQUFLLEVBQUMsR0FBRyxzQkFBaUIsRUFDcEMsS0FBQyxRQUFRLElBQUMsS0FBSyxFQUFDLEdBQUcsdUJBQWtCLEVBQ3JDLEtBQUMsUUFBUSxJQUFDLEtBQUssRUFBQyxHQUFHLHNCQUFpQixJQUMxQixHQUNQLElBQ0YsRUFDUCxNQUFDLFNBQVMsSUFDUixPQUFPLEVBQUMsVUFBVSxFQUNsQixNQUFNLFFBQ04sS0FBSyxFQUFFLFVBQVUsQ0FBQyxTQUFTLEVBQzNCLFFBQVEsRUFBRSxVQUFDLENBQUM7b0JBQ1YsSUFBSSxRQUFRO3dCQUNWLFFBQVEsdUJBQ0gsVUFBVSxLQUNiLFNBQVMsRUFBRSxDQUFDLENBQUMsTUFBTSxDQUFDLEtBQTBDLElBQzlELENBQUE7Z0JBQ04sQ0FBQyxFQUNELElBQUksRUFBQyxPQUFPLGFBRVosS0FBQyxRQUFRLElBQUMsS0FBSyxFQUFDLE1BQU0saUNBQTRCLEVBQ2xELEtBQUMsUUFBUSxJQUFDLEtBQUssRUFBQyxRQUFRLHVCQUFrQixFQUMxQyxLQUFDLFFBQVEsSUFBQyxLQUFLLEVBQUMsT0FBTyxzQkFBaUIsSUFDOUIsSUFDUCxDQUNSLENBQUE7QUFDSCxDQUFDLENBQUEiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgQ29kaWNlIEZvdW5kYXRpb25cbiAqXG4gKiBUaGlzIGlzIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnkgaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyXG4gKiBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieSB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZVxuICogTGljZW5zZSwgb3IgYW55IGxhdGVyIHZlcnNpb24uXG4gKlxuICogVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dFxuICogZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZiBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuIFNlZSB0aGUgR05VXG4gKiBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLiBBIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuICogaXMgZGlzdHJpYnV0ZWQgYWxvbmcgd2l0aCB0aGlzIHByb2dyYW0gYW5kIGNhbiBiZSBmb3VuZCBhdFxuICogPGh0dHA6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy9sZ3BsLmh0bWw+LlxuICpcbiAqKi9cbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0J1xuaW1wb3J0IHsgRGF0ZUlucHV0IH0gZnJvbSAnQGJsdWVwcmludGpzL2RhdGV0aW1lJ1xuaW1wb3J0IHsgRGF0ZUhlbHBlcnMsIERlZmF1bHRNYXhEYXRlLCBEZWZhdWx0TWluRGF0ZSB9IGZyb20gJy4vZGF0ZS1oZWxwZXJzJ1xuaW1wb3J0IHsgTXVpT3V0bGluZWRJbnB1dEJvcmRlckNsYXNzZXMgfSBmcm9tICcuLi90aGVtZS90aGVtZSdcbmltcG9ydCB1c2VUaW1lUHJlZnMgZnJvbSAnLi91c2VUaW1lUHJlZnMnXG5pbXBvcnQgeyBWYWx1ZVR5cGVzIH0gZnJvbSAnLi4vZmlsdGVyLWJ1aWxkZXIvZmlsdGVyLnN0cnVjdHVyZSdcbmltcG9ydCBHcmlkIGZyb20gJ0BtdWkvbWF0ZXJpYWwvR3JpZC9HcmlkJ1xuaW1wb3J0IHsgTnVtYmVyRmllbGQgfSBmcm9tICcuL251bWJlcidcbmltcG9ydCBUZXh0RmllbGQgZnJvbSAnQG11aS9tYXRlcmlhbC9UZXh0RmllbGQvVGV4dEZpZWxkJ1xuaW1wb3J0IE1lbnVJdGVtIGZyb20gJ0BtdWkvbWF0ZXJpYWwvTWVudUl0ZW0vTWVudUl0ZW0nXG5cbmltcG9ydCB1c2VyIGZyb20gJy4uL3NpbmdsZXRvbnMvdXNlci1pbnN0YW5jZSdcbmltcG9ydCB7IEVudGVyS2V5U3VibWl0UHJvcHMgfSBmcm9tICcuLi9jdXN0b20tZXZlbnRzL2VudGVyLWtleS1zdWJtaXQnXG5cbnR5cGUgRGF0ZUFyb3VuZFByb3BzID0ge1xuICB2YWx1ZTogVmFsdWVUeXBlc1snYXJvdW5kJ11cbiAgb25DaGFuZ2U6ICh2YWw6IFZhbHVlVHlwZXNbJ2Fyb3VuZCddKSA9PiB2b2lkXG59XG5cbmNvbnN0IGRlZmF1bHRWYWx1ZSA9ICgpID0+IHtcbiAgcmV0dXJuIHtcbiAgICBkYXRlOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgYnVmZmVyOiB7XG4gICAgICBhbW91bnQ6ICcxJyxcbiAgICAgIHVuaXQ6ICdkJyxcbiAgICB9LFxuICAgIGRpcmVjdGlvbjogJ2JvdGgnLFxuICB9IGFzIFZhbHVlVHlwZXNbJ2Fyb3VuZCddXG59XG5cbmNvbnN0IHZhbGlkYXRlRGF0ZSA9ICh7IHZhbHVlLCBvbkNoYW5nZSB9OiBEYXRlQXJvdW5kUHJvcHMpID0+IHtcbiAgaWYgKFxuICAgICF2YWx1ZS5kYXRlIHx8XG4gICAgIXZhbHVlLmJ1ZmZlciB8fFxuICAgICF2YWx1ZS5kaXJlY3Rpb24gfHxcbiAgICBEYXRlSGVscGVycy5CbHVlcHJpbnQuY29tbW9uUHJvcHMucGFyc2VEYXRlKHZhbHVlLmRhdGUpID09PSBudWxsXG4gICkge1xuICAgIGNvbnN0IG5ld0RhdGUgPSBEYXRlSGVscGVycy5HZW5lcmFsLndpdGhQcmVjaXNpb24obmV3IERhdGUoKSlcbiAgICBvbkNoYW5nZSh7IC4uLmRlZmF1bHRWYWx1ZSgpLCBkYXRlOiBuZXdEYXRlLnRvSVNPU3RyaW5nKCkgfSlcbiAgfVxufVxuXG5leHBvcnQgY29uc3QgRGF0ZUFyb3VuZEZpZWxkID0gKHsgdmFsdWUsIG9uQ2hhbmdlIH06IERhdGVBcm91bmRQcm9wcykgPT4ge1xuICBjb25zdCB2YWxpZFZhbHVlID0ge1xuICAgIC4uLmRlZmF1bHRWYWx1ZSgpLFxuICAgIC4uLnZhbHVlLFxuICB9XG4gIGNvbnN0IGJsdWVwcmludERhdGVSZWYgPSBSZWFjdC51c2VSZWY8RGF0ZUlucHV0PihudWxsKVxuXG4gIHVzZVRpbWVQcmVmcygoKSA9PiB7XG4gICAgY29uc3Qgc2hpZnRlZERhdGUgPSBEYXRlSGVscGVycy5CbHVlcHJpbnQuRGF0ZVByb3BzLmdlbmVyYXRlVmFsdWUoXG4gICAgICB2YWx1ZS5kYXRlXG4gICAgKVxuICAgIGNvbnN0IHVuc2hpZnRlZERhdGUgPVxuICAgICAgRGF0ZUhlbHBlcnMuQmx1ZXByaW50LmNvbnZlcnRlcnMuVW50aW1lc2hpZnRGcm9tRGF0ZVBpY2tlcihzaGlmdGVkRGF0ZSlcbiAgICBvbkNoYW5nZSh7XG4gICAgICAuLi52YWxpZFZhbHVlLFxuICAgICAgZGF0ZTogdW5zaGlmdGVkRGF0ZS50b0lTT1N0cmluZygpLFxuICAgIH0pXG4gIH0pXG5cbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICB2YWxpZGF0ZURhdGUoeyBvbkNoYW5nZSwgdmFsdWUgfSlcbiAgfSwgW10pXG5cbiAgcmV0dXJuIChcbiAgICA8R3JpZCBjb250YWluZXIgYWxpZ25JdGVtcz1cInN0cmV0Y2hcIiBkaXJlY3Rpb249XCJjb2x1bW5cIiB3cmFwPVwibm93cmFwXCI+XG4gICAgICA8R3JpZCBpdGVtIGNsYXNzTmFtZT1cInctZnVsbCBwYi0yXCI+XG4gICAgICAgIDxEYXRlSW5wdXRcbiAgICAgICAgICByZWY9e2JsdWVwcmludERhdGVSZWZ9XG4gICAgICAgICAgdGltZVBpY2tlclByb3BzPXt7XG4gICAgICAgICAgICB1c2VBbVBtOiB1c2VyLmdldEFtUG1EaXNwbGF5KCksXG4gICAgICAgICAgfX1cbiAgICAgICAgICBjbGFzc05hbWU9e011aU91dGxpbmVkSW5wdXRCb3JkZXJDbGFzc2VzfVxuICAgICAgICAgIG1pbkRhdGU9e0RlZmF1bHRNaW5EYXRlfVxuICAgICAgICAgIG1heERhdGU9e0RlZmF1bHRNYXhEYXRlfVxuICAgICAgICAgIGNsb3NlT25TZWxlY3Rpb249e2ZhbHNlfVxuICAgICAgICAgIGZpbGxcbiAgICAgICAgICBmb3JtYXREYXRlPXtEYXRlSGVscGVycy5CbHVlcHJpbnQuY29tbW9uUHJvcHMuZm9ybWF0RGF0ZX1cbiAgICAgICAgICBvbkNoYW5nZT17RGF0ZUhlbHBlcnMuQmx1ZXByaW50LkRhdGVQcm9wcy5nZW5lcmF0ZU9uQ2hhbmdlKChkYXRlKSA9PiB7XG4gICAgICAgICAgICBvbkNoYW5nZSh7XG4gICAgICAgICAgICAgIC4uLnZhbGlkVmFsdWUsXG4gICAgICAgICAgICAgIGRhdGUsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH0pfVxuICAgICAgICAgIHBhcnNlRGF0ZT17RGF0ZUhlbHBlcnMuQmx1ZXByaW50LmNvbW1vblByb3BzLnBhcnNlRGF0ZX1cbiAgICAgICAgICBwbGFjZWhvbGRlcj17RGF0ZUhlbHBlcnMuR2VuZXJhbC5nZXREYXRlRm9ybWF0KCl9XG4gICAgICAgICAgc2hvcnRjdXRzXG4gICAgICAgICAgdGltZVByZWNpc2lvbj17RGF0ZUhlbHBlcnMuR2VuZXJhbC5nZXRUaW1lUHJlY2lzaW9uKCl9XG4gICAgICAgICAgaW5wdXRQcm9wcz17e1xuICAgICAgICAgICAgLi4uRW50ZXJLZXlTdWJtaXRQcm9wcyxcbiAgICAgICAgICB9fVxuICAgICAgICAgIHBvcG92ZXJQcm9wcz17e1xuICAgICAgICAgICAgYm91bmRhcnk6ICd2aWV3cG9ydCcsXG4gICAgICAgICAgICBwb3NpdGlvbjogJ2JvdHRvbScsXG4gICAgICAgICAgICBvbkNsb3NlOiAoKSA9PiB7XG4gICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIGJsdWVwcmludERhdGVSZWYuY3VycmVudD8uc2V0U3RhdGUoeyBpc09wZW46IGZhbHNlIH0pXG4gICAgICAgICAgICAgIH0sIDApXG4gICAgICAgICAgICB9LFxuICAgICAgICAgIH19XG4gICAgICAgICAgdmFsdWU9e0RhdGVIZWxwZXJzLkJsdWVwcmludC5EYXRlUHJvcHMuZ2VuZXJhdGVWYWx1ZSh2YWxpZFZhbHVlLmRhdGUpfVxuICAgICAgICAvPlxuICAgICAgPC9HcmlkPlxuICAgICAgPEdyaWQgaXRlbSBjbGFzc05hbWU9XCJ3LWZ1bGwgcGItMlwiPlxuICAgICAgICB3aXRoIGJ1ZmZlciBvZlxuICAgICAgPC9HcmlkPlxuICAgICAgPEdyaWQgY29udGFpbmVyIGRpcmVjdGlvbj1cInJvd1wiIGNsYXNzTmFtZT1cInctZnVsbFwiPlxuICAgICAgICA8R3JpZCBpdGVtIHhzPXs0fSBjbGFzc05hbWU9XCJwYi0yXCI+XG4gICAgICAgICAgPE51bWJlckZpZWxkXG4gICAgICAgICAgICB0eXBlPVwiZmxvYXRcIlxuICAgICAgICAgICAgb25DaGFuZ2U9eyh2YWwpID0+IHtcbiAgICAgICAgICAgICAgaWYgKG9uQ2hhbmdlKVxuICAgICAgICAgICAgICAgIG9uQ2hhbmdlKHtcbiAgICAgICAgICAgICAgICAgIC4uLnZhbGlkVmFsdWUsXG4gICAgICAgICAgICAgICAgICBidWZmZXI6IHtcbiAgICAgICAgICAgICAgICAgICAgLi4udmFsaWRWYWx1ZS5idWZmZXIsXG4gICAgICAgICAgICAgICAgICAgIGFtb3VudDogdmFsLnRvU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9fVxuICAgICAgICAgICAgdmFsaWRhdGlvbj17KHZhbCkgPT4gdmFsID4gMH1cbiAgICAgICAgICAgIHZhbGlkYXRpb25UZXh0PVwiTXVzdCBiZSBncmVhdGVyIHRoYW4gMCwgdXNpbmcgcHJldmlvdXMgdmFsdWUgb2YgXCJcbiAgICAgICAgICAgIHZhbHVlPXt2YWxpZFZhbHVlLmJ1ZmZlci5hbW91bnR9XG4gICAgICAgICAgLz5cbiAgICAgICAgPC9HcmlkPlxuICAgICAgICA8R3JpZCBpdGVtIHhzPXs4fSBjbGFzc05hbWU9XCJwbC0yXCI+XG4gICAgICAgICAgPFRleHRGaWVsZFxuICAgICAgICAgICAgZnVsbFdpZHRoXG4gICAgICAgICAgICB2YXJpYW50PVwib3V0bGluZWRcIlxuICAgICAgICAgICAgc2VsZWN0XG4gICAgICAgICAgICBvbkNoYW5nZT17KGUpID0+IHtcbiAgICAgICAgICAgICAgaWYgKG9uQ2hhbmdlKVxuICAgICAgICAgICAgICAgIG9uQ2hhbmdlKHtcbiAgICAgICAgICAgICAgICAgIC4uLnZhbGlkVmFsdWUsXG4gICAgICAgICAgICAgICAgICBidWZmZXI6IHtcbiAgICAgICAgICAgICAgICAgICAgLi4udmFsaWRWYWx1ZS5idWZmZXIsXG4gICAgICAgICAgICAgICAgICAgIHVuaXQ6IGUudGFyZ2V0XG4gICAgICAgICAgICAgICAgICAgICAgLnZhbHVlIGFzIFZhbHVlVHlwZXNbJ2Fyb3VuZCddWydidWZmZXInXVsndW5pdCddLFxuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfX1cbiAgICAgICAgICAgIHNpemU9XCJzbWFsbFwiXG4gICAgICAgICAgICB2YWx1ZT17dmFsaWRWYWx1ZS5idWZmZXIudW5pdH1cbiAgICAgICAgICA+XG4gICAgICAgICAgICA8TWVudUl0ZW0gdmFsdWU9XCJzXCI+U2Vjb25kczwvTWVudUl0ZW0+XG4gICAgICAgICAgICA8TWVudUl0ZW0gdmFsdWU9XCJtXCI+TWludXRlczwvTWVudUl0ZW0+XG4gICAgICAgICAgICA8TWVudUl0ZW0gdmFsdWU9XCJoXCI+SG91cnM8L01lbnVJdGVtPlxuICAgICAgICAgICAgPE1lbnVJdGVtIHZhbHVlPVwiZFwiPkRheXM8L01lbnVJdGVtPlxuICAgICAgICAgICAgPE1lbnVJdGVtIHZhbHVlPVwid1wiPldlZWtzPC9NZW51SXRlbT5cbiAgICAgICAgICAgIDxNZW51SXRlbSB2YWx1ZT1cIk1cIj5Nb250aHM8L01lbnVJdGVtPlxuICAgICAgICAgICAgPE1lbnVJdGVtIHZhbHVlPVwieVwiPlllYXJzPC9NZW51SXRlbT5cbiAgICAgICAgICA8L1RleHRGaWVsZD5cbiAgICAgICAgPC9HcmlkPlxuICAgICAgPC9HcmlkPlxuICAgICAgPFRleHRGaWVsZFxuICAgICAgICB2YXJpYW50PVwib3V0bGluZWRcIlxuICAgICAgICBzZWxlY3RcbiAgICAgICAgdmFsdWU9e3ZhbGlkVmFsdWUuZGlyZWN0aW9ufVxuICAgICAgICBvbkNoYW5nZT17KGUpID0+IHtcbiAgICAgICAgICBpZiAob25DaGFuZ2UpXG4gICAgICAgICAgICBvbkNoYW5nZSh7XG4gICAgICAgICAgICAgIC4uLnZhbGlkVmFsdWUsXG4gICAgICAgICAgICAgIGRpcmVjdGlvbjogZS50YXJnZXQudmFsdWUgYXMgVmFsdWVUeXBlc1snYXJvdW5kJ11bJ2RpcmVjdGlvbiddLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgfX1cbiAgICAgICAgc2l6ZT1cInNtYWxsXCJcbiAgICAgID5cbiAgICAgICAgPE1lbnVJdGVtIHZhbHVlPVwiYm90aFwiPkJlZm9yZSBhbmQgQWZ0ZXI8L01lbnVJdGVtPlxuICAgICAgICA8TWVudUl0ZW0gdmFsdWU9XCJiZWZvcmVcIj5CZWZvcmU8L01lbnVJdGVtPlxuICAgICAgICA8TWVudUl0ZW0gdmFsdWU9XCJhZnRlclwiPkFmdGVyPC9NZW51SXRlbT5cbiAgICAgIDwvVGV4dEZpZWxkPlxuICAgIDwvR3JpZD5cbiAgKVxufVxuIl19